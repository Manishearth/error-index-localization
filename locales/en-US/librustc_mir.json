{
  "E0001": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nThis error suggests that the expression arm corresponding to the noted pattern\nwill never be reached as for all possible values of the expression being\nmatched, one of the preceding patterns will match.\n\nThis means that perhaps some of the preceding patterns are too general, this\none is too specific or the ordering is incorrect.\n\nFor example, the following `match` block has too many arms:\n\n```\nmatch Some(0) {\n    Some(bar) => {/* ... */}\n    x => {/* ... */} // This handles the `None` case\n    _ => {/* ... */} // All possible cases have already been handled\n}\n```\n\n`match` blocks have their patterns matched in order, so, for example, putting\na wildcard arm above a more specific arm will make the latter arm irrelevant.\n\nEnsure the ordering of the match arm is correct and remove any superfluous\narms.\n",
    "description": "E0001"
  },
  "E0002": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nThis error indicates that an empty match expression is invalid because the type\nit is matching on is non-empty (there exist values of this type). In safe code\nit is impossible to create an instance of an empty type, so empty match\nexpressions are almost never desired. This error is typically fixed by adding\none or more cases to the match expression.\n\nAn example of an empty type is `enum Empty { }`. So, the following will work:\n\n```\nenum Empty {}\n\nfn foo(x: Empty) {\n    match x {\n        // empty\n    }\n}\n```\n\nHowever, this won't:\n\n```compile_fail\nfn foo(x: Option<String>) {\n    match x {\n        // empty\n    }\n}\n```\n",
    "description": "E0002"
  },
  "E0004": {
    "message": "\nThis error indicates that the compiler cannot guarantee a matching pattern for\none or more possible inputs to a match expression. Guaranteed matches are\nrequired in order to assign values to match expressions, or alternatively,\ndetermine the flow of execution. Erroneous code example:\n\n```compile_fail,E0004\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x { // error: non-exhaustive patterns: `HastaLaVistaBaby` not covered\n    Terminator::TalkToMyHand => {}\n}\n```\n\nIf you encounter this error you must alter your patterns so that every possible\nvalue of the input type is matched. For types with a small number of variants\n(like enums) you should probably cover all cases explicitly. Alternatively, the\nunderscore `_` wildcard pattern can be added after all other patterns to match\n\"anything else\". Example:\n\n```\nenum Terminator {\n    HastaLaVistaBaby,\n    TalkToMyHand,\n}\n\nlet x = Terminator::HastaLaVistaBaby;\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    Terminator::HastaLaVistaBaby => {}\n}\n\n// or:\n\nmatch x {\n    Terminator::TalkToMyHand => {}\n    _ => {}\n}\n```\n",
    "description": "E0004"
  },
  "E0005": {
    "message": "\nPatterns used to bind names must be irrefutable, that is, they must guarantee\nthat a name will be extracted in all cases. Erroneous code example:\n\n```compile_fail,E0005\nlet x = Some(1);\nlet Some(y) = x;\n// error: refutable pattern in local binding: `None` not covered\n```\n\nIf you encounter this error you probably need to use a `match` or `if let` to\ndeal with the possibility of failure. Example:\n\n```\nlet x = Some(1);\n\nmatch x {\n    Some(y) => {\n        // do something\n    },\n    None => {}\n}\n\n// or:\n\nif let Some(y) = x {\n    // do something\n}\n```\n",
    "description": "E0005"
  },
  "E0007": {
    "message": "\nThis error indicates that the bindings in a match arm would require a value to\nbe moved into more than one location, thus violating unique ownership. Code\nlike the following is invalid as it requires the entire `Option<String>` to be\nmoved into a variable called `op_string` while simultaneously requiring the\ninner `String` to be moved into a variable called `s`.\n\n```compile_fail,E0007\nlet x = Some(\"s\".to_string());\n\nmatch x {\n    op_string @ Some(s) => {}, // error: cannot bind by-move with sub-bindings\n    None => {},\n}\n```\n\nSee also the error E0303.\n",
    "description": "E0007"
  },
  "E0008": {
    "message": "\nNames bound in match arms retain their type in pattern guards. As such, if a\nname is bound by move in a pattern, it should also be moved to wherever it is\nreferenced in the pattern guard code. Doing so however would prevent the name\nfrom being available in the body of the match arm. Consider the following:\n\n```compile_fail,E0008\nmatch Some(\"hi\".to_string()) {\n    Some(s) if s.len() == 0 => {}, // use s.\n    _ => {},\n}\n```\n\nThe variable `s` has type `String`, and its use in the guard is as a variable of\ntype `String`. The guard code effectively executes in a separate scope to the\nbody of the arm, so the value would be moved into this anonymous scope and\ntherefore becomes unavailable in the body of the arm.\n\nThe problem above can be solved by using the `ref` keyword.\n\n```\nmatch Some(\"hi\".to_string()) {\n    Some(ref s) if s.len() == 0 => {},\n    _ => {},\n}\n```\n\nThough this example seems innocuous and easy to solve, the problem becomes clear\nwhen it encounters functions which consume the value:\n\n```compile_fail,E0008\nstruct A{}\n\nimpl A {\n    fn consume(self) -> usize {\n        0\n    }\n}\n\nfn main() {\n    let a = Some(A{});\n    match a {\n        Some(y) if y.consume() > 0 => {}\n        _ => {}\n    }\n}\n```\n\nIn this situation, even the `ref` keyword cannot solve it, since borrowed\ncontent cannot be moved. This problem cannot be solved generally. If the value\ncan be cloned, here is a not-so-specific solution:\n\n```\n#[derive(Clone)]\nstruct A{}\n\nimpl A {\n    fn consume(self) -> usize {\n        0\n    }\n}\n\nfn main() {\n    let a = Some(A{});\n    match a{\n        Some(ref y) if y.clone().consume() > 0 => {}\n        _ => {}\n    }\n}\n```\n\nIf the value will be consumed in the pattern guard, using its clone will not\nmove its ownership, so the code works.\n",
    "description": "E0008"
  },
  "E0009": {
    "message": "\nIn a pattern, all values that don't implement the `Copy` trait have to be bound\nthe same way. The goal here is to avoid binding simultaneously by-move and\nby-ref.\n\nThis limitation may be removed in a future version of Rust.\n\nErroneous code example:\n\n```compile_fail,E0009\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((y, ref z)) => {}, // error: cannot bind by-move and by-ref in the\n                            //        same pattern\n    None => panic!()\n}\n```\n\nYou have two solutions:\n\nSolution #1: Bind the pattern's values the same way.\n\n```\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((ref y, ref z)) => {},\n    // or Some((y, z)) => {}\n    None => panic!()\n}\n```\n\nSolution #2: Implement the `Copy` trait for the `X` structure.\n\nHowever, please keep in mind that the first solution should be preferred.\n\n```\n#[derive(Clone, Copy)]\nstruct X { x: (), }\n\nlet x = Some((X { x: () }, X { x: () }));\nmatch x {\n    Some((y, ref z)) => {},\n    None => panic!()\n}\n```\n",
    "description": "E0009"
  },
  "E0010": {
    "message": "\nThe value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time. Erroneous\ncode example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n",
    "description": "E0010"
  },
  "E0013": {
    "message": "\nStatic and const variables can refer to other const variables. But a const\nvariable cannot refer to a static variable. For example, `Y` cannot refer to\n`X` here:\n\n```compile_fail,E0013\nstatic X: i32 = 42;\nconst Y: i32 = X;\n```\n\nTo fix this, the value can be extracted as a const and then used:\n\n```\nconst A: i32 = 42;\nstatic X: i32 = A;\nconst Y: i32 = A;\n```\n",
    "description": "E0013"
  },
  "E0015": {
    "message": "\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors. `const` functions are only\navailable on a nightly compiler. Rust currently does not support more general\ncompile-time function execution.\n\n```\nconst FOO: Option<u8> = Some(1); // enum constructor\nstruct Bar {x: u8}\nconst BAR: Bar = Bar {x: 1}; // struct constructor\n```\n\nSee [RFC 911] for more details on the design of `const fn`s.\n\n[RFC 911]: https://github.com/rust-lang/rfcs/blob/master/text/0911-const-fn.md\n",
    "description": "E0015"
  },
  "E0017": {
    "message": "\nReferences in statics and constants may only refer to immutable values.\nErroneous code example:\n\n```compile_fail,E0017\nstatic X: i32 = 1;\nconst C: i32 = 2;\n\n// these three are not allowed:\nconst CR: &mut i32 = &mut C;\nstatic STATIC_REF: &'static mut i32 = &mut X;\nstatic CONST_REF: &'static mut i32 = &mut C;\n```\n\nStatics are shared everywhere, and if they refer to mutable data one might\nviolate memory safety since holding multiple mutable references to shared data\nis not allowed.\n\nIf you really want global mutable state, try using `static mut` or a global\n`UnsafeCell`.\n",
    "description": "E0017"
  },
  "E0019": {
    "message": "\nA function call isn't allowed in the const's initialization expression\nbecause the expression's value must be known at compile-time. Erroneous code\nexample:\n\n```compile_fail\nenum Test {\n    V1\n}\n\nimpl Test {\n    fn test(&self) -> i32 {\n        12\n    }\n}\n\nfn main() {\n    const FOO: Test = Test::V1;\n\n    const A: i32 = FOO.test(); // You can't call Test::func() here!\n}\n```\n\nRemember: you can't use a function call inside a const's initialization\nexpression! However, you can totally use it anywhere else:\n\n```\nenum Test {\n    V1\n}\n\nimpl Test {\n    fn func(&self) -> i32 {\n        12\n    }\n}\n\nfn main() {\n    const FOO: Test = Test::V1;\n\n    FOO.func(); // here is good\n    let x = FOO.func(); // or even here!\n}\n```\n",
    "description": "E0019"
  },
  "E0030": {
    "message": "\nWhen matching against a range, the compiler verifies that the range is\nnon-empty.  Range patterns include both end-points, so this is equivalent to\nrequiring the start of the range to be less than or equal to the end of the\nrange.\n\nFor example:\n\n```compile_fail\nmatch 5u32 {\n    // This range is ok, albeit pointless.\n    1 ..= 1 => {}\n    // This range is empty, and the compiler can tell.\n    1000 ..= 5 => {}\n}\n```\n",
    "description": "E0030"
  },
  "E0133": {
    "message": "\nUnsafe code was used outside of an unsafe function or block.\n\nErroneous code example:\n\n```compile_fail,E0133\nunsafe fn f() { return; } // This is the unsafe code\n\nfn main() {\n    f(); // error: call to unsafe function requires unsafe function or block\n}\n```\n\nUsing unsafe functionality is potentially dangerous and disallowed by safety\nchecks. Examples:\n\n* Dereferencing raw pointers\n* Calling functions via FFI\n* Calling functions marked unsafe\n\nThese safety checks can be relaxed for a section of the code by wrapping the\nunsafe instructions with an `unsafe` block. For instance:\n\n```\nunsafe fn f() { return; }\n\nfn main() {\n    unsafe { f(); } // ok!\n}\n```\n\nSee also https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html\n",
    "description": "E0133"
  },
  "E0158": {
    "message": "\n`const` and `static` mean different things. A `const` is a compile-time\nconstant, an alias for a literal value. This property means you can match it\ndirectly within a pattern.\n\nThe `static` keyword, on the other hand, guarantees a fixed location in memory.\nThis does not always mean that the value is constant. For example, a global\nmutex can be declared `static` as well.\n\nIf you want to match against a `static`, consider using a guard instead:\n\n```\nstatic FORTY_TWO: i32 = 42;\n\nmatch Some(42) {\n    Some(x) if x == FORTY_TWO => {}\n    _ => {}\n}\n```\n",
    "description": "E0158"
  },
  "E0161": {
    "message": "\nA value was moved. However, its size was not known at compile time, and only\nvalues of a known size can be moved.\n\nErroneous code example:\n\n```compile_fail\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<[isize]> = box *array;\n    // error: cannot move a value of type [isize]: the size of [isize] cannot\n    //        be statically determined\n}\n```\n\nIn Rust, you can only move a value when its size is known at compile time.\n\nTo work around this restriction, consider \"hiding\" the value behind a reference:\neither `&x` or `&mut x`. Since a reference has a fixed size, this lets you move\nit around as usual. Example:\n\n```\n#![feature(box_syntax)]\n\nfn main() {\n    let array: &[isize] = &[1, 2, 3];\n    let _x: Box<&[isize]> = box array; // ok!\n}\n```\n",
    "description": "E0161"
  },
  "E0162": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nAn if-let pattern attempts to match the pattern, and enters the body if the\nmatch was successful. If the match is irrefutable (when it cannot fail to\nmatch), use a regular `let`-binding instead. For instance:\n\n```compile_pass\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\n// This fails to compile because the match is irrefutable.\nif let Irrefutable(x) = irr {\n    // This body will always be executed.\n    // ...\n}\n```\n\nTry this instead:\n\n```\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\nlet Irrefutable(x) = irr;\nprintln!(\"{}\", x);\n```\n",
    "description": "E0162"
  },
  "E0165": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nA while-let pattern attempts to match the pattern, and enters the body if the\nmatch was successful. If the match is irrefutable (when it cannot fail to\nmatch), use a regular `let`-binding inside a `loop` instead. For instance:\n\n```compile_pass,no_run\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\n// This fails to compile because the match is irrefutable.\nwhile let Irrefutable(x) = irr {\n    // ...\n}\n```\n\nTry this instead:\n\n```no_run\nstruct Irrefutable(i32);\nlet irr = Irrefutable(0);\n\nloop {\n    let Irrefutable(x) = irr;\n    // ...\n}\n```\n",
    "description": "E0165"
  },
  "E0170": {
    "message": "\nEnum variants are qualified by default. For example, given this type:\n\n```\nenum Method {\n    GET,\n    POST,\n}\n```\n\nYou would match it using:\n\n```\nenum Method {\n    GET,\n    POST,\n}\n\nlet m = Method::GET;\n\nmatch m {\n    Method::GET => {},\n    Method::POST => {},\n}\n```\n\nIf you don't qualify the names, the code will bind new variables named \"GET\" and\n\"POST\" instead. This behavior is likely not what you want, so `rustc` warns when\nthat happens.\n\nQualified names are good practice, and most code works well with them. But if\nyou prefer them unqualified, you can import the variants into scope:\n\n```\nuse Method::*;\nenum Method { GET, POST }\n# fn main() {}\n```\n\nIf you want others to be able to import variants from your module directly, use\n`pub use`:\n\n```\npub use Method::*;\npub enum Method { GET, POST }\n# fn main() {}\n```\n",
    "description": "E0170"
  },
  "E0297": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nPatterns used to bind names must be irrefutable. That is, they must guarantee\nthat a name will be extracted in all cases. Instead of pattern matching the\nloop variable, consider using a `match` or `if let` inside the loop body. For\ninstance:\n\n```compile_fail,E0005\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\n// This fails because `None` is not covered.\nfor Some(x) in xs {\n    // ...\n}\n```\n\nMatch inside the loop instead:\n\n```\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\nfor item in xs {\n    match item {\n        Some(x) => {},\n        None => {},\n    }\n}\n```\n\nOr use `if let`:\n\n```\nlet xs : Vec<Option<i32>> = vec![Some(1), None];\n\nfor item in xs {\n    if let Some(x) = item {\n        // ...\n    }\n}\n```\n",
    "description": "E0297"
  },
  "E0301": {
    "message": "\nMutable borrows are not allowed in pattern guards, because matching cannot have\nside effects. Side effects could alter the matched object or the environment\non which the match depends in such a way, that the match would not be\nexhaustive. For instance, the following would not match any arm if mutable\nborrows were allowed:\n\n```compile_fail,E0301\nmatch Some(()) {\n    None => { },\n    option if option.take().is_none() => {\n        /* impossible, option is `Some` */\n    },\n    Some(_) => { } // When the previous match failed, the option became `None`.\n}\n```\n",
    "description": "E0301"
  },
  "E0302": {
    "message": "\nAssignments are not allowed in pattern guards, because matching cannot have\nside effects. Side effects could alter the matched object or the environment\non which the match depends in such a way, that the match would not be\nexhaustive. For instance, the following would not match any arm if assignments\nwere allowed:\n\n```compile_fail,E0302\nmatch Some(()) {\n    None => { },\n    option if { option = None; false } => { },\n    Some(_) => { } // When the previous match failed, the option became `None`.\n}\n```\n",
    "description": "E0302"
  },
  "E0303": {
    "message": "\nIn certain cases it is possible for sub-bindings to violate memory safety.\nUpdates to the borrow checker in a future version of Rust may remove this\nrestriction, but for now patterns must be rewritten without sub-bindings.\n\nBefore:\n\n```compile_fail,E0303\nmatch Some(\"hi\".to_string()) {\n    ref op_string_ref @ Some(s) => {},\n    None => {},\n}\n```\n\nAfter:\n\n```\nmatch Some(\"hi\".to_string()) {\n    Some(ref s) => {\n        let op_string_ref = &Some(s);\n        // ...\n    },\n    None => {},\n}\n```\n\nThe `op_string_ref` binding has type `&Option<&String>` in both cases.\n\nSee also https://github.com/rust-lang/rust/issues/14587\n",
    "description": "E0303"
  },
  "E0373": {
    "message": "\nThis error occurs when an attempt is made to use data captured by a closure,\nwhen that data may no longer exist. It's most commonly seen when attempting to\nreturn a closure:\n\n```compile_fail,E0373\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(|y| x + y)\n}\n```\n\nNotice that `x` is stack-allocated by `foo()`. By default, Rust captures\nclosed-over data by reference. This means that once `foo()` returns, `x` no\nlonger exists. An attempt to access `x` within the closure would thus be\nunsafe.\n\nAnother situation where this might be encountered is when spawning threads:\n\n```compile_fail,E0373\nfn foo() {\n    let x = 0u32;\n    let y = 1u32;\n\n    let thr = std::thread::spawn(|| {\n        x + y\n    });\n}\n```\n\nSince our new thread runs in parallel, the stack frame containing `x` and `y`\nmay well have disappeared by the time we try to use them. Even if we call\n`thr.join()` within foo (which blocks until `thr` has completed, ensuring the\nstack frame won't disappear), we will not succeed: the compiler cannot prove\nthat this behaviour is safe, and so won't let us do it.\n\nThe solution to this problem is usually to switch to using a `move` closure.\nThis approach moves (or copies, where possible) data into the closure, rather\nthan taking references to it. For example:\n\n```\nfn foo() -> Box<Fn(u32) -> u32> {\n    let x = 0u32;\n    Box::new(move |y| x + y)\n}\n```\n\nNow that the closure has its own copy of the data, there's no need to worry\nabout safety.\n",
    "description": "E0373"
  },
  "E0381": {
    "message": "\nIt is not allowed to use or capture an uninitialized variable. For example:\n\n```compile_fail,E0381\nfn main() {\n    let x: i32;\n    let y = x; // error, use of possibly uninitialized variable\n}\n```\n\nTo fix this, ensure that any declared variables are initialized before being\nused. Example:\n\n```\nfn main() {\n    let x: i32 = 0;\n    let y = x; // ok!\n}\n```\n",
    "description": "E0381"
  },
  "E0382": {
    "message": "\nThis error occurs when an attempt is made to use a variable after its contents\nhave been moved elsewhere. For example:\n\n```compile_fail,E0382\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = MyStruct{ s: 5u32 };\n    let y = x;\n    x.s = 6;\n    println!(\"{}\", x.s);\n}\n```\n\nSince `MyStruct` is a type that is not marked `Copy`, the data gets moved out\nof `x` when we set `y`. This is fundamental to Rust's ownership system: outside\nof workarounds like `Rc`, a value cannot be owned by more than one variable.\n\nSometimes we don't need to move the value. Using a reference, we can let another\nfunction borrow the value without changing its ownership. In the example below,\nwe don't actually have to move our string to `calculate_length`, we can give it\na reference to it with `&` instead.\n\n```\nfn main() {\n    let s1 = String::from(\"hello\");\n\n    let len = calculate_length(&s1);\n\n    println!(\"The length of '{}' is {}.\", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n}\n```\n\nA mutable reference can be created with `&mut`.\n\nSometimes we don't want a reference, but a duplicate. All types marked `Clone`\ncan be duplicated by calling `.clone()`. Subsequent changes to a clone do not\naffect the original variable.\n\nMost types in the standard library are marked `Clone`. The example below\ndemonstrates using `clone()` on a string. `s1` is first set to \"many\", and then\ncopied to `s2`. Then the first character of `s1` is removed, without affecting\n`s2`. \"any many\" is printed to the console.\n\n```\nfn main() {\n    let mut s1 = String::from(\"many\");\n    let s2 = s1.clone();\n    s1.remove(0);\n    println!(\"{} {}\", s1, s2);\n}\n```\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`. Then we can\n`let p2 = p1` without `p1` being moved.\n\n```\n#[derive(Copy, Clone)]\nstruct Point { x: i32, y: i32 }\n\nfn main() {\n    let mut p1 = Point{ x: -1, y: 2 };\n    let p2 = p1;\n    p1.x = 1;\n    println!(\"p1: {}, {}\", p1.x, p1.y);\n    println!(\"p2: {}, {}\", p2.x, p2.y);\n}\n```\n\nAlternatively, if we don't control the struct's definition, or mutable shared\nownership is truly required, we can use `Rc` and `RefCell`:\n\n```\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\nstruct MyStruct { s: u32 }\n\nfn main() {\n    let mut x = Rc::new(RefCell::new(MyStruct{ s: 5u32 }));\n    let y = x.clone();\n    x.borrow_mut().s = 6;\n    println!(\"{}\", x.borrow().s);\n}\n```\n\nWith this approach, x and y share ownership of the data via the `Rc` (reference\ncount type). `RefCell` essentially performs runtime borrow checking: ensuring\nthat at most one writer or multiple readers can access the data at any one time.\n\nIf you wish to learn more about ownership in Rust, start with the chapter in the\nBook:\n\nhttps://doc.rust-lang.org/book/ch04-00-understanding-ownership.html\n",
    "description": "E0382"
  },
  "E0383": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nThis error occurs when an attempt is made to partially reinitialize a\nstructure that is currently uninitialized.\n\nFor example, this can happen when a drop has taken place:\n\n```compile_fail\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x); // `x` is now uninitialized\nx.a = 2; // error, partial reinitialization of uninitialized structure `t`\n```\n\nThis error can be fixed by fully reinitializing the structure in question:\n\n```\nstruct Foo {\n    a: u32,\n}\nimpl Drop for Foo {\n    fn drop(&mut self) { /* ... */ }\n}\n\nlet mut x = Foo { a: 1 };\ndrop(x);\nx = Foo { a: 2 };\n```\n",
    "description": "E0383"
  },
  "E0384": {
    "message": "\nThis error occurs when an attempt is made to reassign an immutable variable.\nFor example:\n\n```compile_fail,E0384\nfn main() {\n    let x = 3;\n    x = 5; // error, reassignment of immutable variable\n}\n```\n\nBy default, variables in Rust are immutable. To fix this error, add the keyword\n`mut` after the keyword `let` when declaring the variable. For example:\n\n```\nfn main() {\n    let mut x = 3;\n    x = 5;\n}\n```\n",
    "description": "E0384"
  },
  "E0387": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nThis error occurs when an attempt is made to mutate or mutably reference data\nthat a closure has captured immutably. Examples of this error are shown below:\n\n```compile_fail\n// Accepts a function or a closure that captures its environment immutably.\n// Closures passed to foo will not be able to mutate their closed-over state.\nfn foo<F: Fn()>(f: F) { }\n\n// Attempts to mutate closed-over data. Error message reads:\n// `cannot assign to data in a captured outer variable...`\nfn mutable() {\n    let mut x = 0u32;\n    foo(|| x = 2);\n}\n\n// Attempts to take a mutable reference to closed-over data.  Error message\n// reads: `cannot borrow data mutably in a captured outer variable...`\nfn mut_addr() {\n    let mut x = 0u32;\n    foo(|| { let y = &mut x; });\n}\n```\n\nThe problem here is that foo is defined as accepting a parameter of type `Fn`.\nClosures passed into foo will thus be inferred to be of type `Fn`, meaning that\nthey capture their context immutably.\n\nIf the definition of `foo` is under your control, the simplest solution is to\ncapture the data mutably. This can be done by defining `foo` to take FnMut\nrather than Fn:\n\n```\nfn foo<F: FnMut()>(f: F) { }\n```\n\nAlternatively, we can consider using the `Cell` and `RefCell` types to achieve\ninterior mutability through a shared reference. Our example's `mutable`\nfunction could be redefined as below:\n\n```\nuse std::cell::Cell;\n\nfn foo<F: Fn()>(f: F) { }\n\nfn mutable() {\n    let x = Cell::new(0u32);\n    foo(|| x.set(2));\n}\n```\n\nYou can read more about cell types in the API documentation:\n\nhttps://doc.rust-lang.org/std/cell/\n",
    "description": "E0387"
  },
  "E0388": {
    "message": "\nE0388 was removed and is no longer issued.\n",
    "description": "E0388"
  },
  "E0389": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nAn attempt was made to mutate data using a non-mutable reference. This\ncommonly occurs when attempting to assign to a non-mutable reference of a\nmutable reference (`&(&mut T)`).\n\nExample of erroneous code:\n\n```compile_fail\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n    let fancy_ref = &(&mut fancy);\n    fancy_ref.num = 6; // error: cannot assign to data in a `&` reference\n    println!(\"{}\", fancy_ref.num);\n}\n```\n\nHere, `&mut fancy` is mutable, but `&(&mut fancy)` is not. Creating an\nimmutable reference to a value borrows it immutably. There can be multiple\nreferences of type `&(&mut T)` that point to the same value, so they must be\nimmutable to prevent multiple mutable references to the same value.\n\nTo fix this, either remove the outer reference:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &mut fancy;\n    // `fancy_ref` is now &mut FancyNum, rather than &(&mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\"{}\", fancy_ref.num);\n}\n```\n\nOr make the outer reference mutable:\n\n```\nstruct FancyNum {\n    num: u8\n}\n\nfn main() {\n    let mut fancy = FancyNum{ num: 5 };\n\n    let fancy_ref = &mut (&mut fancy);\n    // `fancy_ref` is now &mut(&mut FancyNum), rather than &(&mut FancyNum)\n\n    fancy_ref.num = 6; // No error!\n\n    println!(\"{}\", fancy_ref.num);\n}\n```\n",
    "description": "E0389"
  },
  "E0492": {
    "message": "\nA borrow of a constant containing interior mutability was attempted. Erroneous\ncode example:\n\n```compile_fail,E0492\nuse std::sync::atomic::AtomicUsize;\n\nconst A: AtomicUsize = AtomicUsize::new(0);\nstatic B: &'static AtomicUsize = &A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n```\n\nA `const` represents a constant value that should never change. If one takes\na `&` reference to the constant, then one is taking a pointer to some memory\nlocation containing the value. Normally this is perfectly fine: most values\ncan't be changed via a shared `&` pointer, but interior mutability would allow\nit. That is, a constant value could be mutated. On the other hand, a `static` is\nexplicitly a single memory location, which can be mutated at will.\n\nSo, in order to solve this error, either use statics which are `Sync`:\n\n```\nuse std::sync::atomic::AtomicUsize;\n\nstatic A: AtomicUsize = AtomicUsize::new(0);\nstatic B: &'static AtomicUsize = &A; // ok!\n```\n\nYou can also have this error while using a cell type:\n\n```compile_fail,E0492\nuse std::cell::Cell;\n\nconst A: Cell<usize> = Cell::new(1);\nconst B: &Cell<usize> = &A;\n// error: cannot borrow a constant which may contain interior mutability,\n//        create a static instead\n\n// or:\nstruct C { a: Cell<usize> }\n\nconst D: C = C { a: Cell::new(1) };\nconst E: &Cell<usize> = &D.a; // error\n\n// or:\nconst F: &C = &D; // error\n```\n\nThis is because cell types do operations that are not thread-safe. Due to this,\nthey don't implement Sync and thus can't be placed in statics.\n\nHowever, if you still wish to use these types, you can achieve this by an unsafe\nwrapper:\n\n```\nuse std::cell::Cell;\nuse std::marker::Sync;\n\nstruct NotThreadSafe<T> {\n    value: Cell<T>,\n}\n\nunsafe impl<T> Sync for NotThreadSafe<T> {}\n\nstatic A: NotThreadSafe<usize> = NotThreadSafe { value : Cell::new(1) };\nstatic B: &'static NotThreadSafe<usize> = &A; // ok!\n```\n\nRemember this solution is unsafe! You will have to ensure that accesses to the\ncell are synchronized.\n",
    "description": "E0492"
  },
  "E0499": {
    "message": "\nA variable was borrowed as mutable more than once. Erroneous code example:\n\n```compile_fail,E0499\nlet mut i = 0;\nlet mut x = &mut i;\nlet mut a = &mut i;\nx;\n// error: cannot borrow `i` as mutable more than once at a time\n```\n\nPlease note that in rust, you can either have many immutable references, or one\nmutable reference. Take a look at\nhttps://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html for more\ninformation. Example:\n\n\n```\nlet mut i = 0;\nlet mut x = &mut i; // ok!\n\n// or:\nlet mut i = 0;\nlet a = &i; // ok!\nlet b = &i; // still ok!\nlet c = &i; // still ok!\nb;\na;\n```\n",
    "description": "E0499"
  },
  "E0500": {
    "message": "\nA borrowed variable was used by a closure. Example of erroneous code:\n\n```compile_fail,E0500\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    let starks = || {\n        *jon_snow = 3; // error: closure requires unique access to `jon_snow`\n                       //        but it is already borrowed\n    };\n    println!(\"{}\", nights_watch);\n}\n```\n\nIn here, `jon_snow` is already borrowed by the `nights_watch` reference, so it\ncannot be borrowed by the `starks` closure at the same time. To fix this issue,\nyou can create the closure after the borrow has ended:\n\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let nights_watch = &jon_snow;\n    println!(\"{}\", nights_watch);\n    let starks = || {\n        *jon_snow = 3;\n    };\n}\n```\n\nOr, if the type implements the `Clone` trait, you can clone it between\nclosures:\n\n```\nfn you_know_nothing(jon_snow: &mut i32) {\n    let mut jon_copy = jon_snow.clone();\n    let starks = || {\n        *jon_snow = 3;\n    };\n    println!(\"{}\", jon_copy);\n}\n```\n",
    "description": "E0500"
  },
  "E0501": {
    "message": "\nThis error indicates that a mutable variable is being used while it is still\ncaptured by a closure. Because the closure has borrowed the variable, it is not\navailable for use until the closure goes out of scope.\n\nNote that a capture will either move or borrow a variable, but in this\nsituation, the closure is borrowing the variable. Take a look at\nhttp://rustbyexample.com/fn/closures/capture.html for more information about\ncapturing.\n\nExample of erroneous code:\n\n```compile_fail,E0501\nfn inside_closure(x: &mut i32) {\n    // Actions which require unique access\n}\n\nfn outside_closure(x: &mut i32) {\n    // Actions which require unique access\n}\n\nfn foo(a: &mut i32) {\n    let mut bar = || {\n        inside_closure(a)\n    };\n    outside_closure(a); // error: cannot borrow `*a` as mutable because previous\n                        //        closure requires unique access.\n    bar();\n}\n```\n\nTo fix this error, you can finish using the closure before using the captured\nvariable:\n\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    let mut bar = || {\n        inside_closure(a)\n    };\n    bar();\n    // borrow on `a` ends.\n    outside_closure(a); // ok!\n}\n```\n\nOr you can pass the variable as a parameter to the closure:\n\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    let mut bar = |s: &mut i32| {\n        inside_closure(s)\n    };\n    outside_closure(a);\n    bar(a);\n}\n```\n\nIt may be possible to define the closure later:\n\n```\nfn inside_closure(x: &mut i32) {}\nfn outside_closure(x: &mut i32) {}\n\nfn foo(a: &mut i32) {\n    outside_closure(a);\n    let mut bar = || {\n        inside_closure(a)\n    };\n    bar();\n}\n```\n",
    "description": "E0501"
  },
  "E0502": {
    "message": "\nThis error indicates that you are trying to borrow a variable as mutable when it\nhas already been borrowed as immutable.\n\nExample of erroneous code:\n\n```compile_fail,E0502\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    let ref y = a; // a is borrowed as immutable.\n    bar(a); // error: cannot borrow `*a` as mutable because `a` is also borrowed\n            //        as immutable\n    println!(\"{}\", y);\n}\n```\n\nTo fix this error, ensure that you don't have any other references to the\nvariable before trying to access it mutably:\n\n```\nfn bar(x: &mut i32) {}\nfn foo(a: &mut i32) {\n    bar(a);\n    let ref y = a; // ok!\n    println!(\"{}\", y);\n}\n```\n\nFor more information on the rust ownership system, take a look at\nhttps://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html.\n",
    "description": "E0502"
  },
  "E0503": {
    "message": "\nA value was used after it was mutably borrowed.\n\nExample of erroneous code:\n\n```compile_fail,E0503\nfn main() {\n    let mut value = 3;\n    // Create a mutable borrow of `value`.\n    let borrow = &mut value;\n    let _sum = value + 1; // error: cannot use `value` because\n                          //        it was mutably borrowed\n    println!(\"{}\", borrow);\n}\n```\n\nIn this example, `value` is mutably borrowed by `borrow` and cannot be\nused to calculate `sum`. This is not possible because this would violate\nRust's mutability rules.\n\nYou can fix this error by finishing using the borrow before the next use of\nthe value:\n\n```\nfn main() {\n    let mut value = 3;\n    let borrow = &mut value;\n    println!(\"{}\", borrow);\n    // The block has ended and with it the borrow.\n    // You can now use `value` again.\n    let _sum = value + 1;\n}\n```\n\nOr by cloning `value` before borrowing it:\n\n```\nfn main() {\n    let mut value = 3;\n    // We clone `value`, creating a copy.\n    let value_cloned = value.clone();\n    // The mutable borrow is a reference to `value` and\n    // not to `value_cloned`...\n    let borrow = &mut value;\n    // ... which means we can still use `value_cloned`,\n    let _sum = value_cloned + 1;\n    // even though the borrow only ends here.\n    println!(\"{}\", borrow);\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n",
    "description": "E0503"
  },
  "E0504": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nThis error occurs when an attempt is made to move a borrowed variable into a\nclosure.\n\nExample of erroneous code:\n\n```compile_fail\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        println!(\"child function: {}\", fancy_num.num);\n        // error: cannot move `fancy_num` into closure because it is borrowed\n    };\n\n    x();\n    println!(\"main function: {}\", fancy_ref.num);\n}\n```\n\nHere, `fancy_num` is borrowed by `fancy_ref` and so cannot be moved into\nthe closure `x`. There is no way to move a value into a closure while it is\nborrowed, as that would invalidate the borrow.\n\nIf the closure can't outlive the value being moved, try using a reference\nrather than moving:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n\n    let x = move || {\n        // fancy_ref is usable here because it doesn't move `fancy_num`\n        println!(\"child function: {}\", fancy_ref.num);\n    };\n\n    x();\n\n    println!(\"main function: {}\", fancy_num.num);\n}\n```\n\nIf the value has to be borrowed and then moved, try limiting the lifetime of\nthe borrow using a scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"main function: {}\", fancy_ref.num);\n        // `fancy_ref` goes out of scope here\n    }\n\n    let x = move || {\n        // `fancy_num` can be moved now (no more references exist)\n        println!(\"child function: {}\", fancy_num.num);\n    };\n\n    x();\n}\n```\n\nIf the lifetime of a reference isn't enough, such as in the case of threading,\nconsider using an `Arc` to create a reference-counted value:\n\n```\nuse std::sync::Arc;\nuse std::thread;\n\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let fancy_ref1 = Arc::new(FancyNum { num: 5 });\n    let fancy_ref2 = fancy_ref1.clone();\n\n    let x = thread::spawn(move || {\n        // `fancy_ref1` can be moved and has a `'static` lifetime\n        println!(\"child thread: {}\", fancy_ref1.num);\n    });\n\n    x.join().expect(\"child thread should finish\");\n    println!(\"main thread: {}\", fancy_ref2.num);\n}\n```\n",
    "description": "E0504"
  },
  "E0505": {
    "message": "\nA value was moved out while it was still borrowed.\n\nErroneous code example:\n\n```compile_fail,E0505\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let _ref_to_val: &Value = &x;\n    eat(x);\n    borrow(_ref_to_val);\n}\n```\n\nHere, the function `eat` takes ownership of `x`. However,\n`x` cannot be moved because the borrow to `_ref_to_val`\nneeds to last till the function `borrow`.\nTo fix that you can do a few different things:\n\n* Try to avoid moving the variable.\n* Release borrow before move.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: &Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    eat(&x); // pass by reference, if it's possible\n    borrow(ref_to_val);\n}\n```\n\nOr:\n\n```\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n\n    let ref_to_val: &Value = &x;\n    borrow(ref_to_val);\n    // ref_to_val is no longer used.\n    eat(x);\n}\n```\n\nOr:\n\n```\n#[derive(Clone, Copy)] // implement Copy trait\nstruct Value {}\n\nfn borrow(val: &Value) {}\n\nfn eat(val: Value) {}\n\nfn main() {\n    let x = Value{};\n    let ref_to_val: &Value = &x;\n    eat(x); // it will be copied here.\n    borrow(ref_to_val);\n}\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n",
    "description": "E0505"
  },
  "E0506": {
    "message": "\nThis error occurs when an attempt is made to assign to a borrowed value.\n\nExample of erroneous code:\n\n```compile_fail,E0506\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let fancy_ref = &fancy_num;\n    fancy_num = FancyNum { num: 6 };\n    // error: cannot assign to `fancy_num` because it is borrowed\n\n    println!(\"Num: {}, Ref: {}\", fancy_num.num, fancy_ref.num);\n}\n```\n\nBecause `fancy_ref` still holds a reference to `fancy_num`, `fancy_num` can't\nbe assigned to a new value as it would invalidate the reference.\n\nAlternatively, we can move out of `fancy_num` into a second `fancy_num`:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n    let moved_num = fancy_num;\n    fancy_num = FancyNum { num: 6 };\n\n    println!(\"Num: {}, Moved num: {}\", fancy_num.num, moved_num.num);\n}\n```\n\nIf the value has to be borrowed, try limiting the lifetime of the borrow using\na scoped block:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    {\n        let fancy_ref = &fancy_num;\n        println!(\"Ref: {}\", fancy_ref.num);\n    }\n\n    // Works because `fancy_ref` is no longer in scope\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n```\n\nOr by moving the reference into a function:\n\n```\nstruct FancyNum {\n    num: u8,\n}\n\nfn main() {\n    let mut fancy_num = FancyNum { num: 5 };\n\n    print_fancy_ref(&fancy_num);\n\n    // Works because function borrow has ended\n    fancy_num = FancyNum { num: 6 };\n    println!(\"Num: {}\", fancy_num.num);\n}\n\nfn print_fancy_ref(fancy_ref: &FancyNum){\n    println!(\"Ref: {}\", fancy_ref.num);\n}\n```\n",
    "description": "E0506"
  },
  "E0507": {
    "message": "\nYou tried to move out of a value which was borrowed. Erroneous code example:\n\n```compile_fail,E0507\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // error: cannot move out of borrowed content\n}\n```\n\nHere, the `nothing_is_true` method takes the ownership of `self`. However,\n`self` cannot be moved because `.borrow()` only provides an `&TheDarkKnight`,\nwhich is a borrow of the content owned by the `RefCell`. To fix this error,\nyou have three choices:\n\n* Try to avoid moving the variable.\n* Somehow reclaim the ownership.\n* Implement the `Copy` trait on the type.\n\nExamples:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n    let x = x.into_inner(); // we get back ownership\n\n    x.nothing_is_true(); // ok!\n}\n```\n\nOr:\n\n```\nuse std::cell::RefCell;\n\n#[derive(Clone, Copy)] // we implement the Copy trait\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nfn main() {\n    let x = RefCell::new(TheDarkKnight);\n\n    x.borrow().nothing_is_true(); // ok!\n}\n```\n\nMoving a member out of a mutably borrowed struct will also cause E0507 error:\n\n```compile_fail,E0507\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(self) {}\n}\n\nstruct Batcave {\n    knight: TheDarkKnight\n}\n\nfn main() {\n    let mut cave = Batcave {\n        knight: TheDarkKnight\n    };\n    let borrowed = &mut cave;\n\n    borrowed.knight.nothing_is_true(); // E0507\n}\n```\n\nIt is fine only if you put something back. `mem::replace` can be used for that:\n\n```\n# struct TheDarkKnight;\n# impl TheDarkKnight { fn nothing_is_true(self) {} }\n# struct Batcave { knight: TheDarkKnight }\nuse std::mem;\n\nlet mut cave = Batcave {\n    knight: TheDarkKnight\n};\nlet borrowed = &mut cave;\n\nmem::replace(&mut borrowed.knight, TheDarkKnight).nothing_is_true(); // ok!\n```\n\nYou can find more information about borrowing in the rust-book:\nhttp://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html\n",
    "description": "E0507"
  },
  "E0508": {
    "message": "\nA value was moved out of a non-copy fixed-size array.\n\nExample of erroneous code:\n\n```compile_fail,E0508\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    let _value = array[0]; // error: cannot move out of type `[NonCopy; 1]`,\n                           //        a non-copy fixed-size array\n}\n```\n\nThe first element was moved out of the array, but this is not\npossible because `NonCopy` does not implement the `Copy` trait.\n\nConsider borrowing the element instead of moving it:\n\n```\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    let _value = &array[0]; // Borrowing is allowed, unlike moving.\n}\n```\n\nAlternatively, if your type implements `Clone` and you need to own the value,\nconsider borrowing and then cloning:\n\n```\n#[derive(Clone)]\nstruct NonCopy;\n\nfn main() {\n    let array = [NonCopy; 1];\n    // Now you can clone the array element.\n    let _value = array[0].clone();\n}\n```\n",
    "description": "E0508"
  },
  "E0509": {
    "message": "\nThis error occurs when an attempt is made to move out of a value whose type\nimplements the `Drop` trait.\n\nExample of erroneous code:\n\n```compile_fail,E0509\nstruct FancyNum {\n    num: usize\n}\n\nstruct DropStruct {\n    fancy: FancyNum\n}\n\nimpl Drop for DropStruct {\n    fn drop(&mut self) {\n        // Destruct DropStruct, possibly using FancyNum\n    }\n}\n\nfn main() {\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n    let fancy_field = drop_struct.fancy; // Error E0509\n    println!(\"Fancy: {}\", fancy_field.num);\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n}\n```\n\nHere, we tried to move a field out of a struct of type `DropStruct` which\nimplements the `Drop` trait. However, a struct cannot be dropped if one or\nmore of its fields have been moved.\n\nStructs implementing the `Drop` trait have an implicit destructor that gets\ncalled when they go out of scope. This destructor may use the fields of the\nstruct, so moving out of the struct could make it impossible to run the\ndestructor. Therefore, we must think of all values whose type implements the\n`Drop` trait as single units whose fields cannot be moved.\n\nThis error can be fixed by creating a reference to the fields of a struct,\nenum, or tuple using the `ref` keyword:\n\n```\nstruct FancyNum {\n    num: usize\n}\n\nstruct DropStruct {\n    fancy: FancyNum\n}\n\nimpl Drop for DropStruct {\n    fn drop(&mut self) {\n        // Destruct DropStruct, possibly using FancyNum\n    }\n}\n\nfn main() {\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n    let ref fancy_field = drop_struct.fancy; // No more errors!\n    println!(\"Fancy: {}\", fancy_field.num);\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n}\n```\n\nNote that this technique can also be used in the arms of a match expression:\n\n```\nstruct FancyNum {\n    num: usize\n}\n\nenum DropEnum {\n    Fancy(FancyNum)\n}\n\nimpl Drop for DropEnum {\n    fn drop(&mut self) {\n        // Destruct DropEnum, possibly using FancyNum\n    }\n}\n\nfn main() {\n    // Creates and enum of type `DropEnum`, which implements `Drop`\n    let drop_enum = DropEnum::Fancy(FancyNum{num: 10});\n    match drop_enum {\n        // Creates a reference to the inside of `DropEnum::Fancy`\n        DropEnum::Fancy(ref fancy_field) => // No error!\n            println!(\"It was fancy-- {}!\", fancy_field.num),\n    }\n    // implicit call to `drop_enum.drop()` as drop_enum goes out of scope\n}\n```\n",
    "description": "E0509"
  },
  "E0510": {
    "message": "\nCannot mutate place in this match guard.\n\nWhen matching on a variable it cannot be mutated in the match guards, as this\ncould cause the match to be non-exhaustive:\n\n```compile_fail,E0510\n#![feature(nll, bind_by_move_pattern_guards)]\nlet mut x = Some(0);\nmatch x {\n    None => (),\n    Some(_) if { x = None; false } => (),\n    Some(v) => (), // No longer matches\n}\n```\n\nHere executing `x = None` would modify the value being matched and require us\nto go \"back in time\" to the `None` arm.\n",
    "description": "E0510"
  },
  "E0515": {
    "message": "\nCannot return value that references local variable\n\nLocal variables, function parameters and temporaries are all dropped before the\nend of the function body. So a reference to them cannot be returned.\n\n```compile_fail,E0515\n#![feature(nll)]\nfn get_dangling_reference() -> &'static i32 {\n    let x = 0;\n    &x\n}\n```\n\n```compile_fail,E0515\n#![feature(nll)]\nuse std::slice::Iter;\nfn get_dangling_iterator<'a>() -> Iter<'a, i32> {\n    let v = vec![1, 2, 3];\n    v.iter()\n}\n```\n\nConsider returning an owned value instead:\n\n```\nuse std::vec::IntoIter;\n\nfn get_integer() -> i32 {\n    let x = 0;\n    x\n}\n\nfn get_owned_iterator() -> IntoIter<i32> {\n    let v = vec![1, 2, 3];\n    v.into_iter()\n}\n```\n",
    "description": "E0515"
  },
  "E0579": {
    "message": "\nWhen matching against an exclusive range, the compiler verifies that the range\nis non-empty. Exclusive range patterns include the start point but not the end\npoint, so this is equivalent to requiring the start of the range to be less\nthan the end of the range.\n\nFor example:\n\n```compile_fail\nmatch 5u32 {\n    // This range is ok, albeit pointless.\n    1 .. 2 => {}\n    // This range is empty, and the compiler can tell.\n    5 .. 5 => {}\n}\n```\n",
    "description": "E0579"
  },
  "E0595": {
    "message": "\n#### Note: this error code is no longer emitted by the compiler.\n\nClosures cannot mutate immutable captured variables.\n\nErroneous code example:\n\n```compile_fail,E0594\nlet x = 3; // error: closure cannot assign to immutable local variable `x`\nlet mut c = || { x += 1 };\n```\n\nMake the variable binding mutable:\n\n```\nlet mut x = 3; // ok!\nlet mut c = || { x += 1 };\n```\n",
    "description": "E0595"
  },
  "E0596": {
    "message": "\nThis error occurs because you tried to mutably borrow a non-mutable variable.\n\nExample of erroneous code:\n\n```compile_fail,E0596\nlet x = 1;\nlet y = &mut x; // error: cannot borrow mutably\n```\n\nIn here, `x` isn't mutable, so when we try to mutably borrow it in `y`, it\nfails. To fix this error, you need to make `x` mutable:\n\n```\nlet mut x = 1;\nlet y = &mut x; // ok!\n```\n",
    "description": "E0596"
  },
  "E0597": {
    "message": "\nThis error occurs because a value was dropped while it was still borrowed\n\nExample of erroneous code:\n\n```compile_fail,E0597\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\n{\n    let y = 0;\n    x.x = Some(&y); // error: `y` does not live long enough\n}\nprintln!(\"{:?}\", x.x);\n```\n\nIn here, `y` is dropped at the end of the inner scope, but it is borrowed by\n`x` until the `println`. To fix the previous example, just remove the scope\nso that `y` isn't dropped until after the println\n\n```\nstruct Foo<'a> {\n    x: Option<&'a u32>,\n}\n\nlet mut x = Foo { x: None };\n\nlet y = 0;\nx.x = Some(&y);\n\nprintln!(\"{:?}\", x.x);\n```\n",
    "description": "E0597"
  },
  "E0626": {
    "message": "\nThis error occurs because a borrow in a generator persists across a\nyield point.\n\n```compile_fail,E0626\n# #![feature(generators, generator_trait, pin)]\n# use std::ops::Generator;\n# use std::pin::Pin;\nlet mut b = || {\n    let a = &String::new(); // <-- This borrow...\n    yield (); // ...is still in scope here, when the yield occurs.\n    println!(\"{}\", a);\n};\nPin::new(&mut b).resume();\n```\n\nAt present, it is not permitted to have a yield that occurs while a\nborrow is still in scope. To resolve this error, the borrow must\neither be \"contained\" to a smaller scope that does not overlap the\nyield or else eliminated in another way. So, for example, we might\nresolve the previous example by removing the borrow and just storing\nthe integer by value:\n\n```\n# #![feature(generators, generator_trait, pin)]\n# use std::ops::Generator;\n# use std::pin::Pin;\nlet mut b = || {\n    let a = 3;\n    yield ();\n    println!(\"{}\", a);\n};\nPin::new(&mut b).resume();\n```\n\nThis is a very simple case, of course. In more complex cases, we may\nwish to have more than one reference to the value that was borrowed --\nin those cases, something like the `Rc` or `Arc` types may be useful.\n\nThis error also frequently arises with iteration:\n\n```compile_fail,E0626\n# #![feature(generators, generator_trait, pin)]\n# use std::ops::Generator;\n# use std::pin::Pin;\nlet mut b = || {\n  let v = vec![1,2,3];\n  for &x in &v { // <-- borrow of `v` is still in scope...\n    yield x; // ...when this yield occurs.\n  }\n};\nPin::new(&mut b).resume();\n```\n\nSuch cases can sometimes be resolved by iterating \"by value\" (or using\n`into_iter()`) to avoid borrowing:\n\n```\n# #![feature(generators, generator_trait, pin)]\n# use std::ops::Generator;\n# use std::pin::Pin;\nlet mut b = || {\n  let v = vec![1,2,3];\n  for x in v { // <-- Take ownership of the values instead!\n    yield x; // <-- Now yield is OK.\n  }\n};\nPin::new(&mut b).resume();\n```\n\nIf taking ownership is not an option, using indices can work too:\n\n```\n# #![feature(generators, generator_trait, pin)]\n# use std::ops::Generator;\n# use std::pin::Pin;\nlet mut b = || {\n  let v = vec![1,2,3];\n  let len = v.len(); // (*)\n  for i in 0..len {\n    let x = v[i]; // (*)\n    yield x; // <-- Now yield is OK.\n  }\n};\nPin::new(&mut b).resume();\n\n// (*) -- Unfortunately, these temporaries are currently required.\n// See <https://github.com/rust-lang/rust/issues/43122>.\n```\n",
    "description": "E0626"
  },
  "E0712": {
    "message": "\nThis error occurs because a borrow of a thread-local variable was made inside a\nfunction which outlived the lifetime of the function.\n\nExample of erroneous code:\n\n```compile_fail,E0712\n#![feature(nll)]\n#![feature(thread_local)]\n\n#[thread_local]\nstatic FOO: u8 = 3;\n\nfn main() {\n    let a = &FOO; // error: thread-local variable borrowed past end of function\n\n    std::thread::spawn(move || {\n        println!(\"{}\", a);\n    });\n}\n```\n",
    "description": "E0712"
  },
  "E0713": {
    "message": "\nThis error occurs when an attempt is made to borrow state past the end of the\nlifetime of a type that implements the `Drop` trait.\n\nExample of erroneous code:\n\n```compile_fail,E0713\n#![feature(nll)]\n\npub struct S<'a> { data: &'a mut String }\n\nimpl<'a> Drop for S<'a> {\n    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n}\n\nfn demo<'a>(s: S<'a>) -> &'a mut String { let p = &mut *s.data; p }\n```\n\nHere, `demo` tries to borrow the string data held within its\nargument `s` and then return that borrow. However, `S` is\ndeclared as implementing `Drop`.\n\nStructs implementing the `Drop` trait have an implicit destructor that\ngets called when they go out of scope. This destructor gets exclusive\naccess to the fields of the struct when it runs.\n\nThis means that when `s` reaches the end of `demo`, its destructor\ngets exclusive access to its `&mut`-borrowed string data.  allowing\nanother borrow of that string data (`p`), to exist across the drop of\n`s` would be a violation of the principle that `&mut`-borrows have\nexclusive, unaliased access to their referenced data.\n\nThis error can be fixed by changing `demo` so that the destructor does\nnot run while the string-data is borrowed; for example by taking `S`\nby reference:\n\n```\n#![feature(nll)]\n\npub struct S<'a> { data: &'a mut String }\n\nimpl<'a> Drop for S<'a> {\n    fn drop(&mut self) { self.data.push_str(\"being dropped\"); }\n}\n\nfn demo<'a>(s: &'a mut S<'a>) -> &'a mut String { let p = &mut *(*s).data; p }\n```\n\nNote that this approach needs a reference to S with lifetime `'a`.\nNothing shorter than `'a` will suffice: a shorter lifetime would imply\nthat after `demo` finishes executing, something else (such as the\ndestructor!) could access `s.data` after the end of that shorter\nlifetime, which would again violate the `&mut`-borrow's exclusive\naccess.\n",
    "description": "E0713"
  },
  "E0716": {
    "message": "\nThis error indicates that a temporary value is being dropped\nwhile a borrow is still in active use.\n\nErroneous code example:\n\n```compile_fail,E0716\n# #![feature(nll)]\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet p = bar(&foo());\n         // ------ creates a temporary\nlet q = *p;\n```\n\nHere, the expression `&foo()` is borrowing the expression\n`foo()`. As `foo()` is a call to a function, and not the name of\na variable, this creates a **temporary** -- that temporary stores\nthe return value from `foo()` so that it can be borrowed.\nYou could imagine that `let p = bar(&foo());` is equivalent\nto this:\n\n```compile_fail,E0597\n# fn foo() -> i32 { 22 }\n# fn bar(x: &i32) -> &i32 { x }\nlet p = {\n  let tmp = foo(); // the temporary\n  bar(&tmp)\n}; // <-- tmp is freed as we exit this block\nlet q = p;\n```\n\nWhenever a temporary is created, it is automatically dropped (freed)\naccording to fixed rules. Ordinarily, the temporary is dropped\nat the end of the enclosing statement -- in this case, after the `let`.\nThis is illustrated in the example above by showing that `tmp` would\nbe freed as we exit the block.\n\nTo fix this problem, you need to create a local variable\nto store the value in rather than relying on a temporary.\nFor example, you might change the original program to\nthe following:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = foo(); // dropped at the end of the enclosing block\nlet p = bar(&value);\nlet q = *p;\n```\n\nBy introducing the explicit `let value`, we allocate storage\nthat will last until the end of the enclosing block (when `value`\ngoes out of scope). When we borrow `&value`, we are borrowing a\nlocal variable that already exists, and hence no temporary is created.\n\nTemporaries are not always dropped at the end of the enclosing\nstatement. In simple cases where the `&` expression is immediately\nstored into a variable, the compiler will automatically extend\nthe lifetime of the temporary until the end of the enclosing\nblock. Therefore, an alternative way to fix the original\nprogram is to write `let tmp = &foo()` and not `let tmp = foo()`:\n\n```\nfn foo() -> i32 { 22 }\nfn bar(x: &i32) -> &i32 { x }\nlet value = &foo();\nlet p = bar(value);\nlet q = *p;\n```\n\nHere, we are still borrowing `foo()`, but as the borrow is assigned\ndirectly into a variable, the temporary will not be dropped until\nthe end of the enclosing block. Similar rules apply when temporaries\nare stored into aggregate structures like a tuple or struct:\n\n```\n// Here, two temporaries are created, but\n// as they are stored directly into `value`,\n// they are not dropped until the end of the\n// enclosing block.\nfn foo() -> i32 { 22 }\nlet value = (&foo(), &foo());\n```\n",
    "description": "E0716"
  },
  "E0723": {
    "message": "\nAn feature unstable in `const` contexts was used.\n\nErroneous code example:\n\n```compile_fail,E0723\ntrait T {}\n\nimpl T for () {}\n\nconst fn foo() -> impl T { // error: `impl Trait` in const fn is unstable\n    ()\n}\n```\n\nTo enable this feature on a nightly version of rustc, add the `const_fn`\nfeature flag:\n\n```\n#![feature(const_fn)]\n\ntrait T {}\n\nimpl T for () {}\n\nconst fn foo() -> impl T {\n    ()\n}\n```\n",
    "description": "E0723"
  },
  "E0729": {
    "message": "\nSupport for Non-Lexical Lifetimes (NLL) has been included in the Rust compiler\nsince 1.31, and has been enabled on the 2015 edition since 1.36. The new borrow\nchecker for NLL uncovered some bugs in the old borrow checker, which in some\ncases allowed unsound code to compile, resulting in memory safety issues.\n\n### What do I do?\n\nChange your code so the warning does no longer trigger. For backwards\ncompatibility, this unsound code may still compile (with a warning) right now.\nHowever, at some point in the future, the compiler will no longer accept this\ncode and will throw a hard error.\n\n### Shouldn't you fix the old borrow checker?\n\nThe old borrow checker has known soundness issues that are basically impossible\nto fix. The new NLL-based borrow checker is the fix.\n\n### Can I turn these warnings into errors by denying a lint?\n\nNo.\n\n### When are these warnings going to turn into errors?\n\nNo formal timeline for turning the warnings into errors has been set. See\n[GitHub issue 58781](https://github.com/rust-lang/rust/issues/58781) for more\ninformation.\n\n### Why do I get this message with code that doesn't involve borrowing?\n\nThere are some known bugs that trigger this message.\n",
    "description": "E0729"
  }
}